# 문제
# 계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. 

# <그림 1>과 같이 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.



# <그림 1>

# 예를 들어 <그림 2>와 같이 시작점에서부터 첫 번째, 두 번째, 네 번째, 

# 여섯 번째 계단을 밟아 도착점에 도달하면 총 점수는 10 + 20 + 25 + 20 = 75점이 된다.



# <그림 2>

# 계단 오르는 데는 다음과 같은 규칙이 있다.

# 계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 

# 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.

# 연속된 세 개의 계단을 모두 밟아서는 안 된다. 

# 단, 시작점은 계단에 포함되지 않는다.

# 마지막 도착 계단은 반드시 밟아야 한다.

# 따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 

# 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.

# 각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.

# 입력
# 입력의 첫째 줄에 계단의 개수가 주어진다.

# 둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다. 

# 계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10,000이하의 자연수이다.

# 출력
# 첫째 줄에 계단 오르기 게임에서 얻을 수 있는 총 점수의 최댓값을 출력한다.

# 예제 입력 1 
# 6
# 10
# 20
# 15
# 25
# 10
# 20
# 예제 출력 1 
# 75

# import sys

# input = sys.stdin.readline

# stairs = int(input())
# stair_list = [int(input()) for _ in range(stairs)]

# dp = [0] * 300
# if stairs == 1:
#     dp[0] = stair_list[0]
# elif stairs == 2:
#     dp[0] = stair_list[0]
#     dp[1] = stair_list[0]+stair_list[1]
# else:
#     dp[0] = stair_list[0]
#     dp[1] = stair_list[0]+stair_list[1]
#     dp[2] = max(stair_list[0]+stair_list[2], stair_list[1]+stair_list[2])
#     for i in range(3, stairs):
#         dp[i] = max(stair_list[i] + dp[i-2], dp[i-3]+stair_list[i]+stair_list[i-1])

# print(dp[stairs-1])

# ==========================================================================

# 문제
# 재귀 호출만 생각하면 신이 난다! 아닌가요?

# 다음과 같은 재귀함수 w(a, b, c)가 있다.

# if a <= 0 or b <= 0 or c <= 0, then w(a, b, c) returns:
#     1

# if a > 20 or b > 20 or c > 20, then w(a, b, c) returns:
#     w(20, 20, 20)

# if a < b and b < c, then w(a, b, c) returns:
#     w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c)

# otherwise it returns:
#     w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)
# 위의 함수를 구현하는 것은 매우 쉽다. 

# 하지만, 그대로 구현하면 값을 구하는데 매우 오랜 시간이 걸린다. (예를 들면, a=15, b=15, c=15)

# a, b, c가 주어졌을 때, w(a, b, c)를 출력하는 프로그램을 작성하시오.

# 입력
# 입력은 세 정수 a, b, c로 이루어져 있으며, 한 줄에 하나씩 주어진다. 

# 입력의 마지막은 -1 -1 -1로 나타내며, 세 정수가 모두 -1인 경우는 입력의 마지막을 제외하면 없다.

# 출력
# 입력으로 주어진 각각의 a, b, c에 대해서, w(a, b, c)를 출력한다.

# 제한
# -50 ≤ a, b, c ≤ 50
# 예제 입력 1 
# 1 1 1
# 2 2 2
# 10 4 6
# 50 50 50
# -1 7 18
# -1 -1 -1
# 예제 출력 1 
# w(1, 1, 1) = 2
# w(2, 2, 2) = 4
# w(10, 4, 6) = 523
# w(50, 50, 50) = 1048576
# w(-1, 7, 18) = 1

# if a <= 0 or b <= 0 or c <= 0, then w(a, b, c) returns:
#     1

# if a > 20 or b > 20 or c > 20, then w(a, b, c) returns:
#     w(20, 20, 20)

# if a < b and b < c, then w(a, b, c) returns:
#     w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c)

# otherwise it returns:
#     w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)

# import sys

# input = sys.stdin.readline
# dp = [[[0]*21 for _ in range(21)] for _ in range(21)]
# def w(a, b, c):
#     if a <= 0 or b <= 0 or c <= 0:
#         return 1
#     if a > 20 or b > 20 or c > 20:
#         return w(20,20,20)
#     if dp[a][b][c]:
#         return dp[a][b][c]
#     if a<b<c:
#         dp[a][b][c] = w(a,b,c-1) + w(a, b-1, c-1) - w(a, b-1, c)
#     dp[a][b][c] = w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)
#     return dp[a][b][c]

# while True:
#     a, b, c = map(int, input().split())
#     if a == -1 and b == -1 and c == -1:
#         break
#     print(f"w({a}, {b}, {c}) = {w(a,b,c)}")

# ===================================================================

# 문제
# 오른쪽 그림과 같이 삼각형이 나선 모양으로 놓여져 있다. 

# 첫 삼각형은 정삼각형으로 변의 길이는 1이다. 

# 그 다음에는 다음과 같은 과정으로 정삼각형을 계속 추가한다. 

# 나선에서 가장 긴 변의 길이를 k라 했을 때, 그 변에 길이가 k인 정삼각형을 추가한다.

# 파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이이다. 

# P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9이다.

# N이 주어졌을 때, P(N)을 구하는 프로그램을 작성하시오.

# 입력
# 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. (1 ≤ N ≤ 100)

# 출력
# 각 테스트 케이스마다 P(N)을 출력한다.

# 예제 입력 1 
# 2
# 6
# 12
# 예제 출력 1 
# 3
# 16

import sys

input = sys.stdin.readline
P = [0] * 101 
P[:5] = 1,1,1,2,2
for index in range(5, 101):
    P[index] = int(P[index-1] + P[index-5])
T = int(input())
for _ in range(T):
    N = int(input())
    print(P[N-1])


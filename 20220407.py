# 길이가 n인 정수 배열 arr가 주어집니다. 
# arr를 다음과 같은 과정을 거쳐서 섞은 결과를 return 하도록 solution 함수를 완성해주세요.
# arr의 길이가 1이라면, arr를 그냥 그대로 두고 과정을 종료합니다.
# arr를 앞뒤로 뒤집습니다.
# 만약 arr의 길이가 짝수(2k)라면, 앞뒤로 길이가 k, k인 두 배열로 나눕니다.
# 만약 arr의 길이가 홀수(2k+1)라면, 앞뒤로 길이가 k+1, k인 두 배열로 나눕니다.
# 두 배열에 대해 이 과정을 다시 반복한 뒤, 다시 이어 붙입니다.

arr = [i for i in range(1,7)]

def solution(arr):
    if len(arr) == 1:
        return arr
    arr = arr[::-1]
    if len(arr) % 2:
        front = solution(arr[:len(arr)//2+1])
        back = solution(arr[len(arr)//2+1:])
    else:
        front = solution(arr[:len(arr)//2])
        back = solution(arr[len(arr)//2:])
    
    return front + back

# print(solution(arr))

# ==========================================================================

# 문제
# 옛날 옛적에 수학이 항상 큰 골칫거리였던 나라가 있었다. 

# 이 나라의 국왕 김지민은 다음과 같은 문제를 내고 큰 상금을 걸었다.

# 길이가 N인 정수 배열 A와 B가 있다. 다음과 같이 함수 S를 정의하자.

# S = A[0] × B[0] + ... + A[N-1] × B[N-1]

# S의 값을 가장 작게 만들기 위해 A의 수를 재배열하자. 단, B에 있는 수는 재배열하면 안 된다.

# S의 최솟값을 출력하는 프로그램을 작성하시오.

# 입력
# 첫째 줄에 N이 주어진다. 

# 둘째 줄에는 A에 있는 N개의 수가 순서대로 주어지고, 셋째 줄에는 B에 있는 수가 순서대로 주어진다. 

# N은 50보다 작거나 같은 자연수이고, A와 B의 각 원소는 100보다 작거나 같은 음이 아닌 정수이다.

# 출력
# 첫째 줄에 S의 최솟값을 출력한다.

# 예제 입력 1 
# 5
# 1 1 1 6 0
# 2 7 8 3 1
# 예제 출력 1 
# 18
# 예제 입력 2 
# 3
# 1 1 3
# 10 30 20
# 예제 출력 2 
# 80
# 예제 입력 3 
# 9
# 5 15 100 31 39 0 0 3 26
# 11 12 13 2 3 4 5 9 1
# 예제 출력 3 
# 528

# import sys 

# input = sys.stdin.readline

# N = int(input())
# A = list(map(int, input().split()))
# B = list(map(int, input().split()))
# count = 0
# for i in range(N):
#     count += (A.pop(A.index(min(A))) * B.pop(B.index(max(B))))

# print(count)

# ==========================================================================

# 문제
# 인하은행에는 ATM이 1대밖에 없다. 

# 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 

# 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.

# 사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 

# 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. 

# [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 

# 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 

# 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 

# 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 

# 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다.

# 줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 

# 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 

# 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 

# 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다.

# 줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 

# 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오.

# 입력
# 첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi ≤ 1,000)

# 출력
# 첫째 줄에 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다.

# 예제 입력 1 
# 5
# 3 1 4 3 2
# 예제 출력 1 
# 32

# import sys

# input = sys.stdin.readline
# N = int(input())
# Pi = list(map(int, input().split()))
# min_time = 0
# Pi.sort()
# for i in range(N):
#     min_time += (Pi[i]*(N-i))

# print(min_time)

# ==========================================================================



# 문제
# 타로는 자주 JOI잡화점에서 물건을 산다. 

# JOI잡화점에는 잔돈으로 500엔, 100엔, 50엔, 10엔, 5엔, 1엔이 충분히 있고, 

# 언제나 거스름돈 개수가 가장 적게 잔돈을 준다. 

# 타로가 JOI잡화점에서 물건을 사고 카운터에서 1000엔 지폐를 한장 냈을 때, 

# 받을 잔돈에 포함된 잔돈의 개수를 구하는 프로그램을 작성하시오.

# 입력
# 입력은 한줄로 이루어져있고, 타로가 지불할 돈(1 이상 1000미만의 정수) 1개가 쓰여져있다.

# 출력
# 제출할 출력 파일은 1행으로만 되어 있다. 잔돈에 포함된 매수를 출력하시오.

# 예제 입력 1 
# 380
# 예제 출력 1 
# 4
# 예제 입력 2 
# 1
# 예제 출력 2 
# 15

# import sys 

# input = sys.stdin.readline

# money_list = [500, 100, 50, 10, 5, 1]
# change = 1000-int(input())
# result = 0 
# for i in money_list:
#     if change // i > 0:
#         result += change//i
#         change %= i

# print(result)

# ==========================================================================


# 문제
# 준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.

# 동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 

# 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.

# 입력
# 첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)

# 둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)

# 출력
# 첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.

# 예제 입력 1 
# 10 4200
# 1
# 5
# 10
# 50
# 100
# 500
# 1000
# 5000
# 10000
# 50000
# 예제 출력 1 
# 6
# 예제 입력 2 
# 10 4790
# 1
# 5
# 10
# 50
# 100
# 500
# 1000
# 5000
# 10000
# 50000

# import sys

# input = sys.stdin.readline

# N, K = map(int, input().split())
# Ai = [int(input()) for _ in range(N)][::-1]
# count = 0
# for i in Ai:
#     if K//i > 0:
#         count += K//i
#         K%=i

# print(count)

# ==========================================================================

# 문제
# N(1 ≤ N ≤ 100,000)개의 로프가 있다. 

# 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 

# 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.

# 하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. 

# k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.

# 각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 

# 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.

# 입력
# 첫째 줄에 정수 N이 주어진다. 

# 다음 N개의 줄에는 각 로프가 버틸 수 있는 최대 중량이 주어진다. 

# 이 값은 10,000을 넘지 않는 자연수이다.

# 출력
# 첫째 줄에 답을 출력한다.

# 예제 입력 1 
# 2
# 10
# 15
# 예제 출력 1 
# 20

# import sys

# input = sys.stdin.readline

# N = int(input())
# rope_list = sorted([int(input()) for _ in range(N)], reverse=True)
# weight = []
# for i, rope in enumerate(rope_list):
#     weight.append(rope * (i+1))

# print(max(weight))

# ==========================================================================


# 문제
# 3개의 시간조절용 버튼 A B C가 달린 전자레인지가 있다. 

# 각 버튼마다 일정한 시간이 지정되어 있어 해당 버튼을 한번 누를 때마다 그 시간이 동작시간에 더해진다. 

# 버튼 A, B, C에 지정된 시간은 각각 5분, 1분, 10초이다.

# 냉동음식마다 전자레인지로 요리해야할 시간 T가 초단위로 표시되어 있다. 

# 우리는 A, B, C 3개의 버튼을 적절히 눌러서 그 시간의 합이 정확히 T초가 되도록 해야 한다. 

# 단 버튼 A, B, C를 누른 횟수의 합은 항상 최소가 되어야 한다. 

# 이것을 최소버튼 조작이라고 한다. 

# 만일 요리시간이 100초라고 하면(T=100) B를 1번, C는 4번 누르면 된다. 

# 이와 다르게 C를 10번 눌러도 100초가 되지만 이 경우 10번은 최소 횟수가 아니기 때문이 답이 될 수 없다. 

# 이 경우 B 1번, C 4번, 총 5번이 최소버튼 조작이다. 그리고 T=234와 같이 3개의 버튼으로 시간을 정확히 맞출 수 없는 경우도 있다. 

# 여러분은 주어진 요리시간 T초를 맞추기 위한 최소버튼 조작 방법을 구하는 프로그램을 작성해야 한다. 

# 입력
# 첫 번째 줄에는 요리시간 T(초)가 정수로 주어져 있으며 그 범위는 1 ≤ T ≤ 10,000 이다. 

# 출력
# 여러분은 T초를 위한 최소버튼 조작의 A B C 횟수를 첫 줄에 차례대로 출력해야 한다. 

# 각각의 횟수 사이에는 빈 칸을 둔다. 

# 해당 버튼을 누르지 않는 경우에는 숫자 0을 출력해야한다. 

# 만일 제시된 3개의 버튼으로 T초를 맞출 수 없으면 음수 -1을 첫 줄에 출력해야 한다. 

# 서브태스크
# 번호	배점	제한
# 1	30	
# T ≤ 60

# 2	30	
# T ≤ 300

# 3	40	
# T ≤ 10,000

# 예제 입력 1 
# 100
# 예제 출력 1 
# 0 1 4
# 예제 입력 2 
# 189
# 예제 출력 2 
# -1

import sys

input = sys.stdin.readline

button_list = [300, 60, 10]

T = int(input())
count = ['0' for _ in range(3)]
for index, time in enumerate(button_list):
    if T // time > 0:
        count[index] = str(T//time)
        T %= time

if T:
    print(-1)
else:
    print(' '.join(count))


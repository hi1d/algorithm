# 문제
# 세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 
# 각 원판은 반경이 큰 순서대로 쌓여있다. 
# 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.

# 한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.
# 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.
# 이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 
# 단, 이동 횟수는 최소가 되어야 한다.

# 아래 그림은 원판이 5개인 경우의 예시이다.


# 입력
# 첫째 줄에 첫 번째 장대에 쌓인 원판의 개수 N (1 ≤ N ≤ 20)이 주어진다.

# 출력
# 첫째 줄에 옮긴 횟수 K를 출력한다.

# 두 번째 줄부터 수행 과정을 출력한다. 
# 두 번째 줄부터 K개의 줄에 걸쳐 두 정수 A B를 빈칸을 사이에 두고 출력하는데, 
# 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다.

# 예제 입력 1 
# 3
# 예제 출력 1 
# 7
# 1 3
# 1 2
# 3 2
# 1 3
# 2 1
# 2 3
# 1 3

# def move(start, end):
#     print(start, end)

# def hanoi(N, start, end):
#     hanoi_center(N, start, end, 2)

# def hanoi_center(N, start, end, center):
#     if N == 1:
#         move(start, end)
#         return
#     hanoi_center(N-1, start, center, end)
#     move(start, end)
#     hanoi_center(N-1, center, end, start)

# N = int(input())
# print(2**N-1)
# hanoi(N, 1, 3)
    

# ==============================================================

# 문제
# 2차원 평면 위의 점 N개가 주어진다. 
# 좌표를 y좌표가 증가하는 순으로, 
# y좌표가 같으면 x좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.

# 입력
# 첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 
# 둘째 줄부터 N개의 줄에는 i번점의 위치 xi와 yi가 주어진다. (-100,000 ≤ xi, yi ≤ 100,000) 좌표는 항상 정수이고, 
# 위치가 같은 두 점은 없다.

# 출력
# 첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.

# 예제 입력 1 
# 5
# 0 4
# 1 2
# 1 -1
# 2 2
# 3 3
# 예제 출력 1 
# 1 -1
# 1 2
# 2 2
# 3 3
# 0 4

# N = int(input())
# N_list = []
# for _ in range(N):
#     x, y = map(int, input().split())
#     N_list.append([x,y])

# N_list.sort(key=lambda x : (x[1],x[0]))
# for x,y in N_list:
#     print(x,y)

# ==============================================================

# 문제
# 상근이는 나무 M미터가 필요하다. 
# 근처에 나무를 구입할 곳이 모두 망해버렸기 때문에, 정부에 벌목 허가를 요청했다. 
# 정부는 상근이네 집 근처의 나무 한 줄에 대한 벌목 허가를 내주었고, 상근이는 새로 구입한 목재절단기를 이용해서 나무를 구할것이다.

# 목재절단기는 다음과 같이 동작한다. 
# 먼저, 상근이는 절단기에 높이 H를 지정해야 한다. 
# 높이를 지정하면 톱날이 땅으로부터 H미터 위로 올라간다. 
# 그 다음, 한 줄에 연속해있는 나무를 모두 절단해버린다. 
# 따라서, 높이가 H보다 큰 나무는 H 위의 부분이 잘릴 것이고, 낮은 나무는 잘리지 않을 것이다. 
# 예를 들어, 한 줄에 연속해있는 나무의 높이가 20, 15, 10, 17이라고 하자. 
# 상근이가 높이를 15로 지정했다면, 나무를 자른 뒤의 높이는 15, 15, 10, 15가 될 것이고, 
# 상근이는 길이가 5인 나무와 2인 나무를 들고 집에 갈 것이다. (총 7미터를 집에 들고 간다) 
# 절단기에 설정할 수 있는 높이는 양의 정수 또는 0이다.

# 상근이는 환경에 매우 관심이 많기 때문에, 나무를 필요한 만큼만 집으로 가져가려고 한다.
# 이때, 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.

# 입력
# 첫째 줄에 나무의 수 N과 상근이가 집으로 가져가려고 하는 나무의 길이 M이 주어진다. (1 ≤ N ≤ 1,000,000, 1 ≤ M ≤ 2,000,000,000)

# 둘째 줄에는 나무의 높이가 주어진다. 
# 나무의 높이의 합은 항상 M보다 크거나 같기 때문에, 상근이는 집에 필요한 나무를 항상 가져갈 수 있다. 
# 높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0이다.

# 출력
# 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 출력한다.

# 예제 입력 1       # 예제 출력 1 
# 4 7               15
# 20 15 10 17
# 예제 입력 2       # 예제 출력 2
# 5 20              36
# 4 42 40 26 46

# N, M = map(int, input().split())
# trees = sorted(map(int,input().split()))
# start = 0
# end = trees[-1]
# max_height = 0
# while start <= end:
#     center = (start + end) // 2
#     felling_count = sum([i - center for i in trees if i > center])

#     if felling_count < M:
#         end = center - 1
#     else:
#         max_height = center
#         start = center + 1

# print(max_height)


# ==============================================================

# 문제
# 숫자 카드는 정수 하나가 적혀져 있는 카드이다. 
# 상근이는 숫자 카드 N개를 가지고 있다. 
# 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오.

# 입력
# 첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 
# 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 
# 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다. 
# 두 숫자 카드에 같은 수가 적혀있는 경우는 없다.
# 셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 
# 넷째 줄에는 상근이가 가지고 있는 숫자 카드인지 아닌지를 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 
# 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다

# 출력
# 첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 가지고 있으면 1을, 아니면 0을 공백으로 구분해 출력한다.

# 예제 입력 1 
# 5
# 6 3 2 10 -10
# 8
# 10 9 -5 2 3 4 5 -10
# 예제 출력 1 
# 1 0 0 1 1 0 0 1

N = int(input())
N_list = sorted(list(map(int, input().split())))
M = int(input())
M_list = list(map(int, input().split()))
result_list = []
for i in M_list:
    start = 0
    end = N-1
    flag = False
    while start <= end:
        center = (start+end) // 2
        if N_list[center] == i:
            flag = True
            break
        elif N_list[center] < i:
            start = center + 1
        elif N_list[center] > i:
            end = center -1
    if flag:
        result_list.append('1')
        continue
    result_list.append('0')

print(' '.join(result_list))


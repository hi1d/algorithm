# 정부의 위드코로나 정책에 힘입어 매드업 사옥은 다시 활기를 띄기 시작했습니다. 

# 뿐만 아니라, 확진자가 생긴다면, 빠르게 밀접 접촉자를 파악할 수 있는 시스템을 구축하고 있습니다.
# 매드업은 출입 명부가 있습니다. 
# 출입명부는 다음과 같이 쓰여 있습니다.
# [1, 2, 3, -1, -3, -2]
# 양수는 들어온 해당 사원이 들어왔다는 의미이며, 음수는 해당 사원이 나갔다는 의미 입니다.
# 따라서, 위 출입 명부가 의미하는 것은 다음과 같습니다.
# 1번 사원이 사무실로 들어옴
# 2번 사원이 사무실로 들어옴
# 3번 사원이 사무실로 들어옴
# 1번 사원이 사무실에서 나감
# 3번 사원이 사무실에서 나감
# 2번 사원이 사무실에서 나감
# 이 중 만약 2번 사원이 확진자 라면, 1번 3번 사원은 밀접 접촉자가 됩니다.
# [2, 1, 3, 4, -3, -4, -1, -2, 5, -5, 1, 6, -1, -6] 의 출입 명부에서, 

# 1번 사원이 확진자 라면 밀접 접촉자는 2, 3, 4, 6 사원이 됩니다. 
# 5번 사원은 1번 사원이 사무실에 부재중일때만 사무실에 있었으므로 제외됩니다.
# 이처럼 출입명부와 확진자 1명을 변수로 제공 합니다.
# 사원 번호는 자연수 입니다.
# 감염자는 1명이며, 내부에서 재감염 될 가능성은 0% 입니다.
# 감염자 명단은 라이언이 잘 읽을수 있도록 오름차순으로 정렬해야 합니다.
# 매개변수로는 int[]로 되어 있는 출입 명부와 int로 되어 있는 감염자 사원번호가 제공 됩니다.


def solution(entry_list, target):
    target_in = True
    close_contatct_list = []
    company_in = []
    for i in entry_list:
        if i == target:
            target_in = True
        elif i == -target:
            target_in = False
        

entry_list = [2, 1, 3, 4, -3, -4, -1, -2, 5, -5, 1, 6, -1, -6]
target = 1
# entry_list = [2, 6, 3, 4, -6, 5, -3, -4, -5, -2]
# target = 2
# entry_list = [1,-1,2,-2,3,-3]
# target = 3
# solution(entry_list, target)

# ============================================================

# 길이가 n인 정수 배열 arr가 주어집니다. 
# arr를 다음과 같은 과정을 거쳐서 섞은 결과를 return 하도록 solution 함수를 완성해주세요.
# arr의 길이가 1이라면, arr를 그냥 그대로 두고 과정을 종료합니다.
# arr를 앞뒤로 뒤집습니다.
# 만약 arr의 길이가 짝수(2k)라면, 앞뒤로 길이가 k, k인 두 배열로 나눕니다.
# 만약 arr의 길이가 홀수(2k+1)라면, 앞뒤로 길이가 k+1, k인 두 배열로 나눕니다.
# 두 배열에 대해 이 과정을 다시 반복한 뒤, 다시 이어 붙입니다.

arr = [i for i in range(1,7)]

def solution(arr):
    if len(arr) == 1:
        return arr
    arr = arr[::-1]
    if len(arr) % 2:
        front = solution(arr[:len(arr)//2+1])
        back = solution(arr[len(arr)//2+1:])
    else:
        front = solution(arr[:len(arr)//2])
        back = solution(arr[len(arr)//2:])
    
    return front + back

# print(solution(arr))

# ============================================================


# N자리 이진수 중 1을 K개 포함하면서 3의 배수인 이진수는 모두 몇 개인지 구하려 합니다. 
# 단, N자리 이진수는 0으로 시작하는 경우도 포함합니다.
# 예를 들어 N = 3, K = 2인 경우 3자리 이진수는 000, 001, 010, 011, 100, 101, 110, 111로 총 8개입니다. 
# 이 중 1을 2개 포함하는 이진수는 011, 101, 110이며, 이 중 3의 배수인 이진수는 011, 110으로 총 2개입니다.
# 자릿수 N과 1의 개수 K가 매개변수로 주어질 때, 
# N자리 이진수 중 1을 K개 포함하면서 3의 배수인 이진수는 모두 몇 개인지 return하도록 solution 함수를 완성해주세요.


def solution(N, K):
    count = 0
    for i in range(3,100000000, 3):
        i = bin(i)[2:].zfill(N)
        if sum(map(int, i)) == K:
            print(i, int(i,2))
            count += 1
        elif len(i) > N:
            break
    return count

print(solution(50, 2))
# print(bin(50))
# print(len(bin(1000000000000000)[2:].zfill(3)))

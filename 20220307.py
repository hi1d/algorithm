# 문제
# 긴 기간 동안 여자 친구가 없는 성구는, 드디어 소개팅 제의를 받았다.
# 성구는 오랜만에 들어온 소개팅이라, 가장 소개팅 하기 좋은 날에 만나고 싶고 가장 소개팅을 하면 안되는 날을 피하고 싶다.
# 성구가 생각한 가장 소개팅 하기 좋은 날 계산 방법은 아래와 같다.
# 온도 (20점 만점)
# 20점에서 현재 온도와 22도의 차이의 절댓값을 뺀다
# 예) 16도라면 20 - Math.abs(22-16) = 14
# 날씨 (20점 만점)
# 맑음/구름조금: 20점
# 구름 많음: 17점
# 흐림: 10점
# 비: 5점
# 눈 14점
# 온도, 날씨 점수 합산해서 점수가 가장 높은 날을 선정한다
# 동점이면 토요일, 금요일, 일요일, 수요일, 목요일, 화요일, 월요일 순으로 우선권
# 아래와 같은 경우에는 '가장 소개팅을 하면 안되는 날'이다
# 앞에서 구한 점수가 가장 작은 날 단 아래의 3가지 조건 중 하나 이상을 만족해야 함, 없으면 제외한다
# 날씨가 '흐림' 혹은 '비' 일 경우
# 온도 30도 이상
# 온도 0도 이하
# 비추천하는 날이 없으면 -1을 반환(return)합니다.
# 성구가 성공적인 소개팅을 할 수 있도록, 아래 3가지의 정보가 담긴 일주일 단위의 2중배열을 받아 가장 소개팅 하기 좋은 날과 가장 소개팅을 하면 안되는 날을 배열로 반환(return)하는 solution함수를 작성하시오.
# 배열에 담긴 정보
# #정보 이름값  0하늘상태코드[맑음(1), 구름조금(2), 구름많음(3), 흐림(4)]1강수상태코드[없음(0), 비(1), 눈(2)]     2온도섭씨 온도: number
# 예
# 입력 (월,화,수,목,금,토,일 순서)
# [[1,0,11],[3,1,15],[2,0,16],[4,0,17],[2,0,15],[2,1,14],[2,0,12]]
# [[4,0,12],[1,0,16],[3,0,18],[3,0,17],[2,0,15],[3,2,22],[2,1,17]]
# 결과 (추천,비추천)
# [2, 5] // (추천: 수요일, 비추천: 토요일)
# [5, 0] // (추천: 토요일, 비추천: 월요일)

# data = [[1,0,11],[3,1,15],[2,0,16],[4,0,17],[2,0,15],[2,1,14],[2,0,12]]
# data = [[4,0,12],[1,0,16],[3,0,18],[3,0,17],[2,0,15],[3,2,22],[2,1,17]]
# data = [[3,0,20], [2,1,17], [3,0,17], [2,0,31], [1,0,19], [1,0,10],[4,1,14]]
data = [[3,0,20],[4,1,20],[3,0,17],[2,0,31],[1,0,19],[1,0,19],[1,0,22]]
# data = [[1,2,16],[4,1,16],[3,0,20],[3,0,20],[3,0,20],[3,0,20],[1,0,20]]


def temperature(int):
    return 20 - abs(22-int)

def solution(data):
    good_weather = {1: 20, 2: 20, 3: 17, 4: 10}
    bad_weather = {1: 5, 2: 14}
    equal_first = [0,1,3,2,5,6,4]
    week = []
    for i in data:
        temp = temperature(i[2])
        if i[1]: 
            weather_count = bad_weather[i[1]]
        else:
            weather_count = good_weather[i[0]]
        week.append(temp+weather_count)
    print(week)
    best_count = max(week)
    worst_count = min(week)
    best_count_index = [i for i,j in enumerate(week) if j==best_count]
    best_index = 0
    best_first = 0
    for i in best_count_index:
        if equal_first[i] > best_first:
            best_index = i
            best_first = equal_first[i]
    worst_day = week.index(worst_count)
    
    if data[worst_day][0] != 4 and data[worst_day][1] != 1 and data[worst_day][2] < 30 and data[worst_day][2] > 0:
        worst_day = -1

    return [best_index, worst_day]


# print(solution(data))


# ===========================================================================

# 문제 설명
# 대학생이 된 루다는 교양 수학 과목을 들으면서 소수에 대해서 공부하게 되었습니다. 공부를 하던 루다는 N 이하의 소수를 차례대로 나열해 보았습니다. 아래는 N = 39 이하의 소수를 나열해 본 결과입니다.
#          2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37
# 나열된 소수를 보고 있던 루다는 자연수 N 이하의 소수들을 활용하여 연속된 소수의 합이 M이 되는 경우의 수가 얼마나 있는지 궁금해 졌습니다.
# 가령 N = 20, M = 36이라면 20 이하의 소수들을 활용하여 36 = 5 + 7 + 11 + 13과 36 = 17 + 19로 표현 가능하기 때문에 두 가지의 경우의 수가 있습니다.
# N = 100, M = 83이라면 100 이하의 소수를 활용하여 83 = 11 + 13 + 17 + 19 + 23이나 83 = 23 + 29 + 31로 표현 할 수 있으며 83 자체로 소수이기 때문에 총 세 가지의 표현이 가능합니다.
# 여기서 중요한 점은 N = 12, M = 10 일 때 10 = 2 + 3 + 5로 표현할 수 있지만 10 = 3 + 7과 같이 연속된 소수로 이루어지지 않은 경우나 10 = 5 + 5과 같이 같은 숫자를 여러 번 사용하는 경우는 세지 않는다는 것입니다.
# 루다를 도와서 N 이하의 소수를 활용하여 연속된 소수의 합이 M이 되는 경우의 수를 찾아주세요.
# 입력
# 사용할 소수의 범위 2<= N <=3,000,000
# 연속된 소수의 합으로 나타내고 싶은 2<=M<=1,000,000,000
# 입출력 예
# N     M       Return
# 20    36      2
# 100   83      3
# 12    10      1

N = 100
M = 83

def prime(num):
    sieve = [True] * (num+1)
    m = int(num ** 0.5)
    for i in range(2, m+1):
        if sieve[i] == True:
            for j in range(i+i, num+1, i):
                sieve[j] = False
    return [i for i in range(2, num) if sieve[i] == True]

def solution(N, M):
    N = prime(N)
    result = 0
    for i in range(len(N)):
        if N[i] == M:
            result+=1
            continue
        save_num = [N[i]]
        for j in range(i+1, len(N)):
            save_num.append(N[j])
            if sum(save_num) == M:
                result +=1
    return result

# print(solution(N, M))
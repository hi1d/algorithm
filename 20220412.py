# ===================================================================

# 신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 

# 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.

# 예를 들어 7대의 컴퓨터가 <그림 1>과 같이 네트워크 상에서 연결되어 있다고 하자. 

# 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 

# 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 

# 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.

# 어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 

# 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 

# 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.

# 입력
# 첫째 줄에는 컴퓨터의 수가 주어진다. 

# 컴퓨터의 수는 100 이하이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 

# 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 

# 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.

# 출력
# 1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.

# 예제 입력 1 
# 7
# 6
# 1 2
# 2 3
# 1 5
# 5 2
# 5 6
# 4 7

# import sys

# input = sys.stdin.readline

# T = int(input())
# connect_count = int(input())

# node = {i:[] for i in range(1,T+1)}

# for _ in range(connect_count):
#     connect_1, connect_2 = map(int, input().split())
#     node[connect_1].append(connect_2)
#     node[connect_2].append(connect_1)

# def dfs(graph, root):
#     visit = {}
#     stack = [] 

#     stack.append(root)
#     while stack:
#         node = stack.pop()
#         if node not in visit:
#             visit[node] = True
#             stack.extend(graph[node])
#     return len(visit)-1

# print(dfs(node, 1))

# ===================================================================

# 널리 잘 알려진 자료구조 중 최소 힙이 있다. 

# 최소 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.

# 배열에 자연수 x를 넣는다.
# 배열에서 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다.
# 프로그램은 처음에 비어있는 배열에서 시작하게 된다.

# 입력
# 첫째 줄에 연산의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 

# 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 

# 만약 x가 자연수라면 배열에 x라는 값을 넣는(추가하는) 연산이고, 

# x가 0이라면 배열에서 가장 작은 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 

# x는 231보다 작은 자연수 또는 0이고, 음의 정수는 입력으로 주어지지 않는다.

# 출력
# 입력에서 0이 주어진 횟수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 작은 값을 출력하라고 한 경우에는 0을 출력하면 된다.

# 예제 입력 1 
# 9
# 0
# 12345678
# 1
# 2
# 0
# 0
# 0
# 0
# 32
# 예제 출력 1 
# 0
# 1
# 2
# 12345678
# 0

# import sys
# import heapq

# input = sys.stdin.readline
# N = int(input())
# heap = []
# for _ in range(N):
#     x = int(input())
#     if not x:
#         if heap:
#             print(heapq.heappop(heap))
#             continue
#         else:
#             print(0)
#             continue
#     heapq.heappush(heap, x)

# ===================================================================

# 널리 잘 알려진 자료구조 중 최대 힙이 있다. 

# 최대 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.

# 배열에 자연수 x를 넣는다.
# 배열에서 가장 큰 값을 출력하고, 그 값을 배열에서 제거한다.
# 프로그램은 처음에 비어있는 배열에서 시작하게 된다.

# 입력
# 첫째 줄에 연산의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 

# 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 

# 만약 x가 자연수라면 배열에 x라는 값을 넣는(추가하는) 연산이고, 

# x가 0이라면 배열에서 가장 큰 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 

# 입력되는 자연수는 231보다 작다.

# 출력
# 입력에서 0이 주어진 회수만큼 답을 출력한다. 

# 만약 배열이 비어 있는 경우인데 가장 큰 값을 출력하라고 한 경우에는 0을 출력하면 된다.

# 예제 입력 1 
# 13
# 0
# 1
# 2
# 0
# 0
# 3
# 2
# 1
# 0
# 0
# 0
# 0
# 0
# 예제 출력 1 
# 0
# 2
# 1
# 3
# 2
# 1
# 0
# 0

import sys
import heapq

input = sys.stdin.readline
N = int(input())
heap = []
for _ in range(N):
    x = int(input())
    if not x:
        if heap:
            print(heapq.heappop(heap)[1])
            continue
        else:
            print(0)
            continue
    heapq.heappush(heap, (-x, x))
